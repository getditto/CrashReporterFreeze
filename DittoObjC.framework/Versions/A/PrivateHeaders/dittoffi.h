/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_DITTOFFI__
#define __RUST_DITTOFFI__
#ifdef __cplusplus
extern "C" {
#endif


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  This enum contains all the Ditto types exposed publicly. The IDs **MUST**
 *  not be modified otherwise this would break the type conversions.
 *
 *  CHECKME: When merging with Russell's work on explicit types, this enum may
 *  be duplicated.
 */
typedef enum DittoCrdtType {
    /** <No documentation available> */
    DITTO_CRDT_TYPE_COUNTER = 0,
    /** <No documentation available> */
    DITTO_CRDT_TYPE_REGISTER = 1,
    /** <No documentation available> */
    DITTO_CRDT_TYPE_ATTACHMENT = 2,
    /** <No documentation available> */
    DITTO_CRDT_TYPE_RGA = 3,
    /** <No documentation available> */
    DITTO_CRDT_TYPE_R_W_MAP = 4,
} DittoCrdtType_t;

/** \brief
 *  A short-lived FFI object to let an SDK handle an authentication request
 *  in an async manner.
 */
typedef struct CAuthServerAuthRequest CAuthServerAuthRequest_t;

/** <No documentation available> */
void
/* fn */ auth_server_auth_submit_with_error (
    CAuthServerAuthRequest_t * req,
    uint32_t _error_code);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_uint8_t;

/** <No documentation available> */
void
/* fn */ auth_server_auth_submit_with_success (
    CAuthServerAuthRequest_t * req,
    slice_ref_uint8_t success_cbor);

/** <No documentation available> */
typedef struct CAuthServerRefreshRequest CAuthServerRefreshRequest_t;

/** <No documentation available> */
void
/* fn */ auth_server_refresh_submit_with_error (
    CAuthServerRefreshRequest_t * req,
    uint32_t _error_code);

/** <No documentation available> */
void
/* fn */ auth_server_refresh_submit_with_success (
    CAuthServerRefreshRequest_t * req,
    slice_ref_uint8_t success_cbor);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_AwdlClientPlatformEvent TransportHandle_AwdlClientPlatformEvent_t;

/** \brief
 *  Generic enum used by crate and platforms to indicate a connection status
 */
typedef enum ConnectState {
    /** <No documentation available> */
    CONNECT_STATE_DISCONNECTED,
    /** <No documentation available> */
    CONNECT_STATE_CONNECTED,
    /** <No documentation available> */
    CONNECT_STATE_CONNECTING,
    /** <No documentation available> */
    CONNECT_STATE_DISCONNECTING,
} ConnectState_t;

/** \brief
 *  The platform advises Rust that a peer has changed its current connection
 *  status
 */
void
/* fn */ awdl_client_connect_state_changed (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce,
    ConnectState_t state);

/** \brief
 *  The platform advises Rust that a complete message has been received from a
 *  remote peer
 */
void
/* fn */ awdl_client_data_available (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The SDK requests to drop its handle to the AWDL Client Transport
 *
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void
/* fn */ awdl_client_free_handle (
    TransportHandle_AwdlClientPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that a peer has been identified. We know only its
 *  announce string.
 */
void
/* fn */ awdl_client_platform_peer_appeared (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The platform advises Rust that a peer has disappeared.
 */
void
/* fn */ awdl_client_platform_peer_disappeared (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  The platform advises Rust that a given peer is now clear to queue up a new
 *  message whenever one is ready to go
 */
void
/* fn */ awdl_client_ready_to_send (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    char const * announce);

/** \brief
 *  Generic enum used by crate and platforms to indicate online-ness.
 *
 *  In other words, is something active or not? Not everything will use the
 *  transitional states.
 */
typedef enum OnlineState {
    /** <No documentation available> */
    ONLINE_STATE_OFFLINE,
    /** <No documentation available> */
    ONLINE_STATE_ONLINE,
    /** <No documentation available> */
    ONLINE_STATE_GOING_ONLINE,
    /** <No documentation available> */
    ONLINE_STATE_GOING_OFFLINE,
} OnlineState_t;

/** \brief
 *  A code reported by platforms/transports to indicate specific health
 *  conditions
 */
typedef enum TransportCondition {
    /** \brief
     *  A default state. Only use this for transient conditions, e.g., we are
     *  waiting for a platform to finish starting up. If everything is just
     *  quiet, use `Ok`.
     */
    TRANSPORT_CONDITION_UNKNOWN,
    /** \brief
     *  No known problems.
     */
    TRANSPORT_CONDITION_OK,
    /** \brief
     *  Catch-all failure, particularly for unexpected/internal faults. If
     *  possible, add a new case that the customer will be able to
     *  interpret.
     */
    TRANSPORT_CONDITION_GENERIC_FAILURE,
    /** \brief
     *  App is in background.
     */
    TRANSPORT_CONDITION_APP_IN_BACKGROUND,
    /** \brief
     *  We are not able to publish or discover with the mDNS daemon.
     */
    TRANSPORT_CONDITION_MDNS_FAILURE,
    /** \brief
     *  We cannot bind to a port.
     */
    TRANSPORT_CONDITION_TCP_LISTEN_FAILURE,
    /** \brief
     *  No app permission to act as a BLE Central.
     */
    TRANSPORT_CONDITION_NO_BLE_CENTRAL_PERMISSION,
    /** \brief
     *  No app permission to act as a BLE Peripheral.
     */
    TRANSPORT_CONDITION_NO_BLE_PERIPHERAL_PERMISSION,
    /** \brief
     *  This Transport targets a particular peer and we can't reach them right
     *  now.
     */
    TRANSPORT_CONDITION_CANNOT_ESTABLISH_CONNECTION,
    /** \brief
     *  The device has Bluetooth disabled at the OS level.
     */
    TRANSPORT_CONDITION_BLE_DISABLED,
    /** \brief
     *  The device has no Bluetooth hardware.
     */
    TRANSPORT_CONDITION_NO_BLE_HARDWARE,
    /** \brief
     *  The device has Wifi disabled at the OS level.
     */
    TRANSPORT_CONDITION_WIFI_DISABLED,
    /** \brief
     *  The platform has suspended briefly for internal reasons. Peers are
     *  reset.
     */
    TRANSPORT_CONDITION_TEMPORARILY_UNAVAILABLE,
} TransportCondition_t;

/** \brief
 *  The platform advises Rust that searching status changed
 */
void
/* fn */ awdl_client_scanning_state_changed (
    TransportHandle_AwdlClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_AwdlServerPlatformEvent TransportHandle_AwdlServerPlatformEvent_t;

/** \brief
 *  The platform advises Rust that advertising status changed
 */
void
/* fn */ awdl_server_advertising_state_changed (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The platform advises Rust that a peer has changed its current connection
 *  status
 */
void
/* fn */ awdl_server_connect_state_changed (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id,
    ConnectState_t state);

/** \brief
 *  The platform advises Rust that a complete message has been received from a
 *  remote peer
 */
void
/* fn */ awdl_server_data_available (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The SDK requests to drop its handle to the AWDL Server Transport
 *
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void
/* fn */ awdl_server_free_handle (
    TransportHandle_AwdlServerPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that a peer has been identified. We know only its
 *  announce string.
 */
void
/* fn */ awdl_server_platform_peer_appeared (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The platform advises Rust that a peer has disappeared.
 */
void
/* fn */ awdl_server_platform_peer_disappeared (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  The platform advises Rust that a given peer is now clear to queue up a new
 *  message whenever one is ready to go
 */
void
/* fn */ awdl_server_ready_to_send (
    TransportHandle_AwdlServerPlatformEvent_t const * handle,
    int64_t platform_id);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_BleClientPlatformEvent TransportHandle_BleClientPlatformEvent_t;

typedef struct {
    uint8_t idx[16];
} uint8_16_array_t;

/** <No documentation available> */
void
/* fn */ ble_advertisement_heard (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    slice_ref_uint8_t local_name,
    float rssi);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_BleServerPlatformEvent TransportHandle_BleServerPlatformEvent_t;

/** <No documentation available> */
void
/* fn */ ble_advertising_state_changed (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t result);

/** <No documentation available> */
void
/* fn */ ble_central_finished_connecting (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    slice_ref_uint8_t announce,
    int32_t l2cap_available,
    uint32_t mtu);

/** <No documentation available> */
void
/* fn */ ble_central_l2cap_data_available (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** <No documentation available> */
void
/* fn */ ble_central_l2cap_ready_to_send (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** <No documentation available> */
void
/* fn */ ble_central_mtu_updated (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    uint32_t mtu);

/** <No documentation available> */
void
/* fn */ ble_central_ready_to_send (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** <No documentation available> */
void
/* fn */ ble_central_unsubscribed (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * central_uuid);

/** \brief
 *  The SDK requests to drop its handle to the BLE Client Transport
 *
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void
/* fn */ ble_client_free_handle (
    TransportHandle_BleClientPlatformEvent_t * handle);

/** <No documentation available> */
void
/* fn */ ble_connection_state_changed (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    ConnectState_t state,
    int32_t l2cap_available,
    uint32_t mtu);

/** <No documentation available> */
void
/* fn */ ble_peripheral_l2cap_data_available (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** <No documentation available> */
void
/* fn */ ble_peripheral_l2cap_ready_to_send (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** <No documentation available> */
void
/* fn */ ble_peripheral_mtu_updated (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid,
    uint32_t mtu);

/** <No documentation available> */
void
/* fn */ ble_peripheral_ready_to_send (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * uuid);

/** \brief
 *  When receiving data from a Bluetooth LE peer, such as a characteristic
 *  write, indicates what sort of data it is.
 */
typedef enum BleDataType {
    /** \brief
     *  The data _should_ contain the remote peer's announce string.
     *  Used during handshake.
     */
    BLE_DATA_TYPE_ANNOUNCE = 0,
    /** \brief
     *  Data message
     */
    BLE_DATA_TYPE_MESH_DATA = 1,
    /** \brief
     *  Control message
     */
    BLE_DATA_TYPE_CONTROL = 2,
} BleDataType_t;

/** <No documentation available> */
void
/* fn */ ble_received_from_central (
    TransportHandle_BleServerPlatformEvent_t const * handle,
    uint8_16_array_t const * central_uuid,
    BleDataType_t data_type,
    slice_ref_uint8_t data);

/** <No documentation available> */
void
/* fn */ ble_received_from_peripheral (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    uint8_16_array_t const * peripheral_uuid,
    BleDataType_t data_type,
    slice_ref_uint8_t data);

/** <No documentation available> */
void
/* fn */ ble_scanning_state_changed (
    TransportHandle_BleClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t result);

/** \brief
 *  The SDK requests to drop its handle to the BLE Server Transport
 *
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void
/* fn */ ble_server_free_handle (
    TransportHandle_BleServerPlatformEvent_t * handle);

/** <No documentation available> */
typedef struct CDitto CDitto_t;

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_uint8_t;

/** <No documentation available> */
typedef struct AwdlClientCallbacks {
    /** <No documentation available> */
    void (*start_searching)(void *, char const *, char const *);

    /** <No documentation available> */
    void (*stop_searching)(void *);

    /** <No documentation available> */
    void (*request_connect)(void *, char const *);

    /** <No documentation available> */
    void (*request_disconnect)(void *, char const *);

    /** <No documentation available> */
    int32_t (*send_data)(void *, char const *, slice_ref_uint8_t);

    /** <No documentation available> */
    int32_t (*read_data)(void *, char const *, slice_mut_uint8_t);
} AwdlClientCallbacks_t;

/** <No documentation available> */
TransportHandle_AwdlClientPlatformEvent_t *
/* fn */ ditto_add_awdl_client_transport (
    CDitto_t * ditto,
    AwdlClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** <No documentation available> */
typedef struct AwdlServerCallbacks {
    /** <No documentation available> */
    void (*start_advertising)(void *, char const *, char const *);

    /** <No documentation available> */
    void (*stop_advertising)(void *);

    /** <No documentation available> */
    void (*request_disconnect)(void *, int64_t);

    /** <No documentation available> */
    int32_t (*send_data)(void *, int64_t, slice_ref_uint8_t);

    /** <No documentation available> */
    int32_t (*read_data)(void *, int64_t, slice_mut_uint8_t);
} AwdlServerCallbacks_t;

/** <No documentation available> */
TransportHandle_AwdlServerPlatformEvent_t *
/* fn */ ditto_add_awdl_server_transport (
    CDitto_t * ditto,
    AwdlServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));


#include <stdbool.h>

/** \brief
 *  Rust-level representation of the result of a send operation, converted from
 *  a bitfield
 */
typedef struct SendResult {
    /** <No documentation available> */
    bool accepted;

    /** <No documentation available> */
    bool wait_for_ready;
} SendResult_t;

/** <No documentation available> */
typedef struct BleClientCallbacks {
    /** <No documentation available> */
    void (*start_scanning)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

    /** <No documentation available> */
    void (*stop_scanning)(void *);

    /** <No documentation available> */
    OnlineState_t (*scanning_state)(void *);

    /** <No documentation available> */
    void (*connect_peripheral)(void *, uint8_16_array_t const *);

    /** <No documentation available> */
    void (*disconnect_peripheral)(void *, uint8_16_array_t const *);

    /** <No documentation available> */
    SendResult_t (*write_to_peripheral)(void *, BleDataType_t, uint8_16_array_t const *, slice_ref_uint8_t);

    /** <No documentation available> */
    bool (*app_is_in_foreground)(void *);

    /** <No documentation available> */
    int32_t (*read_l2cap_from_peripheral)(void *, uint8_16_array_t const *, slice_mut_uint8_t);

    /** <No documentation available> */
    int32_t (*send_l2cap_to_peripheral)(void *, uint8_16_array_t const *, slice_ref_uint8_t);
} BleClientCallbacks_t;

/** <No documentation available> */
TransportHandle_BleClientPlatformEvent_t *
/* fn */ ditto_add_ble_client_transport (
    CDitto_t * ditto,
    BleClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** <No documentation available> */
typedef struct BleServerCallbacks {
    /** <No documentation available> */
    void (*start_advertising)(void *, uint8_16_array_t const *, slice_ref_uint8_t);

    /** <No documentation available> */
    void (*stop_advertising)(void *);

    /** <No documentation available> */
    OnlineState_t (*advertising_state)(void *);

    /** <No documentation available> */
    SendResult_t (*notify_to_central)(void *, BleDataType_t, uint8_16_array_t const *, slice_ref_uint8_t);

    /** <No documentation available> */
    bool (*app_is_in_foreground)(void *);

    /** <No documentation available> */
    int32_t (*read_l2cap_from_central)(void *, uint8_16_array_t const *, slice_mut_uint8_t);

    /** <No documentation available> */
    int32_t (*send_l2cap_to_central)(void *, uint8_16_array_t const *, slice_ref_uint8_t);
} BleServerCallbacks_t;

/** <No documentation available> */
TransportHandle_BleServerPlatformEvent_t *
/* fn */ ditto_add_ble_server_transport (
    CDitto_t * ditto,
    BleServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** \brief
 *  Requested reliability level for a message to be transmitted to another peer.
 *
 *  Related to Link's
 *  [`StreamReliability`](`::ditto_link::protocol::StreamReliability`).
 */
typedef enum ReliabilityMode {
    /** \brief
     *  No guarantees of successful delivery, ordering, or once-only delivery
     */
    RELIABILITY_MODE_UNRELIABLE,
    /** \brief
     *  Messages will be delivered at most once, in the same order that they are sent,
     *  but there may be gaps.
     */
    RELIABILITY_MODE_UNRELIABLE_SEQUENCED,
    /** \brief
     *  Every message will be delivered in order or else the connection fails
     */
    RELIABILITY_MODE_RELIABLE,
} ReliabilityMode_t;

/** \brief
 *  FFI version of CompletionReason
 */
typedef enum BusCompletionReason {
    /** <No documentation available> */
    BUS_COMPLETION_REASON_CLOSED_BY_REMOTE,
    /** <No documentation available> */
    BUS_COMPLETION_REASON_CLOSED_BY_LOCAL,
} BusCompletionReason_t;

/** \brief
 *  FFI mapping of SingleSendError results
 */
typedef enum BusSingleSendResult {
    /** <No documentation available> */
    BUS_SINGLE_SEND_RESULT_OK,
    /** <No documentation available> */
    BUS_SINGLE_SEND_RESULT_PAYLOAD_TOO_LARGE,
    /** <No documentation available> */
    BUS_SINGLE_SEND_RESULT_QUEUE_FULL,
    /** <No documentation available> */
    BUS_SINGLE_SEND_RESULT_STREAM_FAILED,
} BusSingleSendResult_t;

/** <No documentation available> */
typedef struct BusCallbacks {
    /** <No documentation available> */
    void (*new_incoming_stream)(void *, uint64_t, slice_ref_uint8_t, ReliabilityMode_t, uint64_t);

    /** <No documentation available> */
    void (*stream_open_succeeded)(void *, uint64_t, ReliabilityMode_t, uint64_t);

    /** <No documentation available> */
    void (*stream_open_failed)(void *, uint64_t);

    /** <No documentation available> */
    void (*stream_send_completed)(void *, uint64_t, uint32_t, uint64_t);

    /** <No documentation available> */
    void (*stream_closed)(void *, uint64_t, BusCompletionReason_t);

    /** <No documentation available> */
    void (*stream_incoming_message)(void *, uint64_t, slice_ref_uint8_t);

    /** <No documentation available> */
    void (*stream_remote_ack)(void *, uint64_t, uint64_t);

    /** <No documentation available> */
    void (*single_message_received)(void *, uint64_t, slice_ref_uint8_t, slice_ref_uint8_t);

    /** <No documentation available> */
    void (*finished_sending_single_message)(void *, uint64_t, ReliabilityMode_t, BusSingleSendResult_t);
} BusCallbacks_t;

/** <No documentation available> */
void
/* fn */ ditto_add_bus (
    CDitto_t const * ditto,
    BusCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** <No documentation available> */
TransportHandle_BleClientPlatformEvent_t *
/* fn */ ditto_add_internal_ble_client_transport (
    CDitto_t * ditto);

/** <No documentation available> */
TransportHandle_BleServerPlatformEvent_t *
/* fn */ ditto_add_internal_ble_server_transport (
    CDitto_t * ditto);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_MdnsServerPlatformEvent TransportHandle_MdnsServerPlatformEvent_t;

/** <No documentation available> */
TransportHandle_MdnsServerPlatformEvent_t *
/* fn */ ditto_add_internal_mdns_advertiser (
    CDitto_t * ditto);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_MdnsClientPlatformEvent TransportHandle_MdnsClientPlatformEvent_t;

/** <No documentation available> */
TransportHandle_MdnsClientPlatformEvent_t *
/* fn */ ditto_add_internal_mdns_transport (
    CDitto_t * ditto);

/** <No documentation available> */
typedef struct MdnsServerCallbacks {
    /** <No documentation available> */
    void (*start_advertising)(void *, char const *, char const *, uint16_t);

    /** <No documentation available> */
    void (*stop_advertising)(void *);
} MdnsServerCallbacks_t;

/** <No documentation available> */
TransportHandle_MdnsServerPlatformEvent_t *
/* fn */ ditto_add_mdns_advertiser (
    CDitto_t * ditto,
    MdnsServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** <No documentation available> */
typedef struct MdnsClientCallbacks {
    /** <No documentation available> */
    void (*start_searching)(void *, char const *);

    /** <No documentation available> */
    void (*stop_searching)(void *);

    /** <No documentation available> */
    void (*resolve_service)(void *, slice_ref_uint8_t);
} MdnsClientCallbacks_t;

/** <No documentation available> */
TransportHandle_MdnsClientPlatformEvent_t *
/* fn */ ditto_add_mdns_transport (
    CDitto_t * ditto,
    MdnsClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** <No documentation available> */
void
/* fn */ ditto_add_multicast_transport (
    CDitto_t * ditto);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_StaticTcpClientPlatformEvent TransportHandle_StaticTcpClientPlatformEvent_t;

/** <No documentation available> */
TransportHandle_StaticTcpClientPlatformEvent_t *
/* fn */ ditto_add_static_tcp_client (
    CDitto_t const * ditto,
    char const * address);

/** <No documentation available> */
typedef enum QuerySortDirection {
    /** <No documentation available> */
    QUERY_SORT_DIRECTION_ASCENDING = 1,
    /** <No documentation available> */
    QUERY_SORT_DIRECTION_DESCENDING,
} QuerySortDirection_t;

/** \brief
 *  OrderBy Parameter
 */
typedef struct COrderByParam {
    /** <No documentation available> */
    char const * query_c_str;

    /** <No documentation available> */
    QuerySortDirection_t direction;
} COrderByParam_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_COrderByParam {
    /** \brief
     *  Pointer to the first element (if any).
     */
    COrderByParam_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_COrderByParam_t;

/** <No documentation available> */
int32_t
/* fn */ ditto_add_subscription (
    CDitto_t const * ditto,
    char const * collection,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by,
    int32_t limit,
    uint32_t offset);

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_WebsocketClientPlatformEvent TransportHandle_WebsocketClientPlatformEvent_t;

/** <No documentation available> */
TransportHandle_WebsocketClientPlatformEvent_t *
/* fn */ ditto_add_websocket_client (
    CDitto_t const * ditto,
    char const * address,
    uint32_t routing_hint);

/** <No documentation available> */
typedef struct WifiAwareClientCallbacks {
    /** <No documentation available> */
    void (*start_searching)(void *, char const *);

    /** <No documentation available> */
    void (*stop_searching)(void *);

    /** <No documentation available> */
    void (*create_network)(void *, char const *);
} WifiAwareClientCallbacks_t;

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_WifiAwareClientPlatformEvent TransportHandle_WifiAwareClientPlatformEvent_t;

/** <No documentation available> */
TransportHandle_WifiAwareClientPlatformEvent_t *
/* fn */ ditto_add_wifi_aware_client_transport (
    CDitto_t * ditto,
    WifiAwareClientCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** <No documentation available> */
typedef struct WifiAwareServerCallbacks {
    /** <No documentation available> */
    void (*start_advertising)(void *, char const *, char const *, uint16_t);

    /** <No documentation available> */
    void (*stop_advertising)(void *);
} WifiAwareServerCallbacks_t;

/** \brief
 *  An opaque handle for each installed transport, heap-allocated and owned by
 *  the SDK.
 *
 *  A pointer to this handle is used to send platform events over FFI. In the
 *  future this handle will be the SDK's only point of control over the
 *  transport once created. In particular, a transport will be removed by
 *  freeing the handle. The concept of online and offline will be eliminated.
 *  (i.e., if you don't want a transport, remove it.)
 *
 *  For now, the `Peer` object holds the transports and provides an API based on
 *  a numeric id assigned to each transport instance. Until that is removed, the
 *  id still exists and the SDK can request it from the opaque handle over FFI.
 *
 *  For each transport type, define an `extern "C"` function to free that
 *  specific monomorphisation of the `TransportHandle` using `Box::from_raw`,
 *  plus a function to retrieve the transport id, which will be removed later.
 *
 *  Safety: The SDK owns the `TransportHandle`. It is responsible for ensuring
 *  that it does not use the pointer to the `TransportHandle` after freeing it
 *  with its respective function. In Rust we will assume it is okay to unsafely
 *  dereference a handle.
 *
 *  The C interface of `TransportHandle` is thread-safe (`Send + Sync`).
 */
typedef struct TransportHandle_WifiAwareServerPlatformEvent TransportHandle_WifiAwareServerPlatformEvent_t;

/** <No documentation available> */
TransportHandle_WifiAwareServerPlatformEvent_t *
/* fn */ ditto_add_wifi_aware_server_advertiser (
    CDitto_t * ditto,
    WifiAwareServerCallbacks_t callbacks,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *));

/** <No documentation available> */
typedef struct CAuthClient CAuthClient_t;

/** <No documentation available> */
void
/* fn */ ditto_auth_client_free (
    CAuthClient_t * auth_client);

/** <No documentation available> */
char *
/* fn */ ditto_auth_client_get_app_id (
    CAuthClient_t const * auth_client);

/** <No documentation available> */
uint64_t
/* fn */ ditto_auth_client_get_site_id (
    CAuthClient_t const * auth_client);

/** <No documentation available> */
int32_t
/* fn */ ditto_auth_client_is_web_valid (
    CAuthClient_t const * auth_client);

/** <No documentation available> */
int32_t
/* fn */ ditto_auth_client_is_x509_valid (
    CAuthClient_t const * auth_client);

/** <No documentation available> */
int32_t
/* fn */ ditto_auth_client_login_with_credentials (
    CAuthClient_t const * auth_client,
    char const * username,
    char const * password,
    char const * provider);

/** <No documentation available> */
int32_t
/* fn */ ditto_auth_client_login_with_token (
    CAuthClient_t const * auth_client,
    char const * token,
    char const * provider);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_uint8 {
    /** <No documentation available> */
    uint8_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_uint8_t;

/** <No documentation available> */
typedef struct AuthenticationResult {
    /** <No documentation available> */
    int32_t return_code;

    /** <No documentation available> */
    Vec_uint8_t client_info;
} AuthenticationResult_t;

/** <No documentation available> */
AuthenticationResult_t
/* fn */ ditto_auth_client_login_with_token_and_feedback (
    CAuthClient_t const * auth_client,
    char const * token,
    char const * provider);

/** \brief
 *  Trigger an explicit logout and purge of any cached credentials
 */
int32_t
/* fn */ ditto_auth_client_logout (
    CAuthClient_t const * auth_client);

/** <No documentation available> */
typedef struct AuthClientResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    CAuthClient_t * auth_client;
} AuthClientResult_t;

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_anonymous_client (
    char const * working_dir,
    char const * app_id,
    char const * shared_token,
    char const * base_url);

/** \brief
 *  this struct holds on to a reference to the underlying tokio executor, used during Ditto initialization and for
 *  setting up an AuthClient. unlike [TaskExecutor], it owns the runtime if one was spawned during
 *  initial authentication or when setting up a [UninitalizedDitto](crate::ditto::UninitializedDitto). however, this struct can also be constructed from a
 *  [Handle] passed to it from a parent tokio runtime - this is mainly useful for rust clients where holding onto
 *  multiple [Runtime]s can cause problems. in either case, it provides a safe [block_on](Self::block_on) function that can be
 *  called from within either the asynchronous or synchronous contexts. however, usage of this struct with a [Handle]
 *  requires a multithread [Runtime]. [block_on](Self::block_on) will panic if called from within the context of a
 *  current_thread [Runtime].
 *
 *  think of this struct like [Cow](std::borrow::Cow)<[Runtime]>.
 */
typedef struct CExecutor CExecutor_t;

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_anonymous_client_with_executor (
    char const * working_dir,
    char const * app_id,
    char const * shared_token,
    char const * base_url,
    CExecutor_t * executor);

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_for_development (
    char const * working_dir,
    char const * app_id,
    uint64_t site_id);

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_for_development_with_executor (
    char const * working_dir,
    char const * app_id,
    uint64_t site_id,
    CExecutor_t * executor);

/** \brief
 *  An `SdkLoginProvider` that sends the notifications over FFI
 */
typedef struct CLoginProvider CLoginProvider_t;

/** \brief
 *  Create a LoginProvider. Ownership passes to the SDK.
 *
 *  This cannot be freed directly - it should be passed in when creating an
 *  AuthClient.
 */
CLoginProvider_t *
/* fn */ ditto_auth_client_make_login_provider (
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*expiring_cb)(void *, uint32_t));

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_with_shared_key (
    char const * working_dir,
    char const * app_id,
    char const * key_der_b64,
    uint64_t site_id);

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_with_shared_key_with_executor (
    char const * working_dir,
    char const * app_id,
    char const * key_der_b64,
    uint64_t site_id,
    CExecutor_t * executor);

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_with_static_x509 (
    char const * config_cbor_b64);

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_with_static_x509_with_executor (
    char const * config_cbor_b64,
    CExecutor_t * executor);

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_with_web (
    char const * working_dir,
    char const * app_id,
    char const * base_url,
    CLoginProvider_t * login_provider);

/** <No documentation available> */
AuthClientResult_t
/* fn */ ditto_auth_client_make_with_web_with_executor (
    char const * working_dir,
    char const * app_id,
    char const * base_url,
    CLoginProvider_t * login_provider,
    CExecutor_t * executor);

/** \brief
 *  Create a LoginProvider. Ownership passes to the SDK.
 *
 *  This cannot be freed directly - it should be passed in when creating an
 *  AuthClient.
 */
void
/* fn */ ditto_auth_client_set_validity_listener (
    CAuthClient_t const * auth_client,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*validity_update_cb)(void *, int32_t, int32_t));

/** <No documentation available> */
char *
/* fn */ ditto_auth_client_user_id (
    CAuthClient_t const * auth_client);

/** <No documentation available> */
CExecutor_t *
/* fn */ ditto_auth_extract_executor (
    CAuthClient_t const * auth_client);

/** <No documentation available> */
void
/* fn */ ditto_auth_login_provider_free (
    CLoginProvider_t * login_provider);

/** <No documentation available> */
void
/* fn */ ditto_bus_close_stream (
    CDitto_t const * ditto,
    uint64_t stream_id);

/** <No documentation available> */
void
/* fn */ ditto_bus_enqueue_stream_message (
    CDitto_t const * ditto,
    uint64_t stream_id,
    slice_ref_uint8_t message);

/** <No documentation available> */
typedef enum BusStreamEnqueueReadiness {
    /** <No documentation available> */
    BUS_STREAM_ENQUEUE_READINESS_READY,
    /** <No documentation available> */
    BUS_STREAM_ENQUEUE_READINESS_NOT_READY,
    /** <No documentation available> */
    BUS_STREAM_ENQUEUE_READINESS_ERROR,
} BusStreamEnqueueReadiness_t;

/** <No documentation available> */
BusStreamEnqueueReadiness_t
/* fn */ ditto_bus_is_stream_ready_to_enqueue (
    CDitto_t const * ditto,
    uint64_t stream_id);

/** <No documentation available> */
void
/* fn */ ditto_bus_open_stream (
    CDitto_t const * ditto,
    uint64_t destination,
    ReliabilityMode_t reliability_mode,
    uint64_t open_ctx);

/** <No documentation available> */
void
/* fn */ ditto_bus_send_single_message (
    CDitto_t const * ditto,
    uint64_t destination,
    uint64_t send_ctx,
    ReliabilityMode_t reliability_mode,
    slice_ref_uint8_t message);

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_boxed_uint8_t;

/** \brief
 *  Releases a byte array value returned by DittoStore.
 *
 *  DittoStore manages its own memory allocations and it is not safe to release
 *  such values with C's `free()`. That's why the structures it returns provide
 *  their own associated `free` function.
 *
 *  It should be used for values returned by functions like
 *  `ditto_document_cbor`.
 */
void
/* fn */ ditto_c_bytes_free (
    slice_boxed_uint8_t bytes);

/** \brief
 *  Releases `char *` value returned by DittoStore.
 *
 *  DittoStore manages its own memory allocations and it is not safe to release
 *  such values with C's `free()`. That's why the structures it returns provide
 *  their own associated `free` function and this is one we need for `char *`.
 *
 *  It should be used for values returned by functions like
 *  `ditto_document_id_query_compatible`.
 */
void
/* fn */ ditto_c_string_free (
    char * s);

/** \brief
 *  Empty error callback
 *  (useful for passing to `err_cb` functions to ignore errors; use with
 *  caution)
 */
void
/* fn */ ditto_callback_err_nop (
    int32_t _code,
    char const * _err,
    void * _data);

/** \brief
 *  Empty callback (useful for passing to `free` functions)
 */
void
/* fn */ ditto_callback_nop (
    void const * _data);

/** \brief
 *  Cancels a resolve callback registered by ditto_resolve_attachment.
 *
 *  Returns following error codes:
 *
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- invalid id
 *  * `3` -- token not found
 *
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
uint32_t
/* fn */ ditto_cancel_resolve_attachment (
    CDitto_t const * ditto,
    slice_ref_uint8_t id,
    uint64_t cancel_token);

/** \brief
 *  The `PathAccessorType` enum allows you to specify (usually from the SDK side
 *  of the FFI) what sort of type youre trying to access. So for some of the
 *  cases in the enum, e.g. `String`, `Bool`, etc, its quite straightforward
 *  what youre asking for. For something like `Int` its a little more complex
 *  in that if the value at the path youve provided is an integer _or_ a float
 *  (with no fractional part to it) then itll return an integer to you. For
 *  `Array` or `Object` itll give you back an array or an object (respectively)
 *  if either the value at the path provided is a `Register` containing an
 *  array/object or if the value at the path provided is an `RGA`/`RWMap`,
 *  respectively.
 *
 *  There are then the explicit type accessor type cases in that enum, e.g.
 *  `RGA`, `Counter`, etc which will only return a value if the active value
 *  (most recently updated) at the provided path is a CRDT of the specified
 *  type, otherwise `None` will be returned.
 */
typedef enum PathAccessorType {
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_STRING,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_NUMBER,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_INT,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_U_INT,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_FLOAT,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_DOUBLE,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_BOOL,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_NULL,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_OBJECT,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_ARRAY,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_ANY,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_COUNTER,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_REGISTER,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_ATTACHMENT,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_RGA,
    /** <No documentation available> */
    PATH_ACCESSOR_TYPE_R_W_MAP,
} PathAccessorType_t;

/** <No documentation available> */
typedef struct CBORPathResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    slice_boxed_uint8_t cbor;
} CBORPathResult_t;

/** \brief
 *  Gets the CBOR value at the path in the provided CBOR and returns it if the
 *  value found matches the type requested, otherwise `None` will be returned in
 *  the result.
 *
 *  If CBOR is returned in the result then the bytes have to be released with
 *  `::ditto_c_bytes_free`.
 */
CBORPathResult_t
/* fn */ ditto_cbor_get_cbor_with_path_type (
    slice_ref_uint8_t cbor,
    char const * path,
    PathAccessorType_t path_type);

/** \brief
 *  Deregister any presence callback, releasing the receiver on the SDK side.
 */
void
/* fn */ ditto_clear_presence_callback (
    CDitto_t * ditto);

/** \brief
 *  Deregister v1 presence callback, releasing the receiver on the SDK side.
 */
void
/* fn */ ditto_clear_presence_v1_callback (
    CDitto_t * ditto);

/** \brief
 *  Deregister v2 presence callback, releasing the receiver on the SDK side.
 */
void
/* fn */ ditto_clear_presence_v2_callback (
    CDitto_t * ditto);

/** \brief
 *  Deregister v3 presence callback, releasing the receiver on the SDK side.
 */
void
/* fn */ ditto_clear_presence_v3_callback (
    CDitto_t * ditto);

/** <No documentation available> */
int32_t
/* fn */ ditto_collection (
    CDitto_t const * ditto,
    char const * name);

/** \brief
 *  Write transaction synchronous API.
 */
typedef struct CWriteTransaction CWriteTransaction_t;

/** <No documentation available> */
typedef struct BoolResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    bool bool_value;
} BoolResult_t;

/** \brief
 *  Evict a document from the collection, using the provided write transaction.
 *
 *  `was_evicted` is set to indicate whether the document was removed
 *  successfully.
 *
 *  * [js only] Returns -1 in case of outstanding non-`await`ed transaction operation.
 */
BoolResult_t
/* fn */ ditto_collection_evict (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    slice_ref_uint8_t id);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_slice_boxed_uint8 {
    /** <No documentation available> */
    slice_boxed_uint8_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_slice_boxed_uint8_t;

/** <No documentation available> */
typedef struct DocIdsResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    Vec_slice_boxed_uint8_t ids;
} DocIdsResult_t;

/** \brief
 *  Evict all documents returned by the specified query from a collection.
 *
 *  `out_ids` is set to the list of IDs of all documents successfully evicted.
 *
 *  [js only] Returns -2 in case of outstanding non-awaited transaction operation.
 */
DocIdsResult_t
/* fn */ ditto_collection_evict_query_str (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset);

/** \brief
 *  Database document consisting of an associate `DocumentId` and
 *  `ditto_crdt::Document` pair. Within the `store` crate the association of
 *  these two elements are maintained together within this single structure,
 *  while these elements may be stored separately in upstream or downstream
 *  crates. This type corresponds to the `Record` type in the `replication`
 *  crate, rather than a literal document.
 */
typedef struct CDocument CDocument_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CDocument_ptr {
    /** <No documentation available> */
    CDocument_t * * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CDocument_ptr_t;

/** <No documentation available> */
typedef struct DocumentsResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    Vec_CDocument_ptr_t documents;
} DocumentsResult_t;

/** \brief
 *  Execute the specified query on a collection.
 *
 *  `out_documents` is set to the list of all documents successfully retrieved
 *  from the collection.
 *
 *  [js only] Returns -2 in case of outstanding non-awaited transaction operation.
 */
DocumentsResult_t
/* fn */ ditto_collection_exec_query_str (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * txn,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset);

/** \brief
 *  Read transaction synchronous API.
 */
typedef struct CReadTransaction CReadTransaction_t;

/** <No documentation available> */
typedef struct DocumentResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    CDocument_t * document;
} DocumentResult_t;

/** \brief
 *  [js only] Returns `-1` in case of outstanding non-`awaited` transaction operation.
 */
DocumentResult_t
/* fn */ ditto_collection_get (
    CDitto_t const * ditto,
    char const * coll_name,
    slice_ref_uint8_t id,
    CReadTransaction_t * transaction);

/** <No documentation available> */
typedef enum WriteStrategyRs {
    /** \brief
     *  Create or merge with existing data
     */
    WRITE_STRATEGY_RS_MERGE,
    /** \brief
     *  Only insert if no document already exists with the same document ID
     */
    WRITE_STRATEGY_RS_INSERT_IF_ABSENT,
    /** \brief
     *  Insert as default data, only if no document already exists with the same
     *  document ID
     */
    WRITE_STRATEGY_RS_INSERT_DEFAULT_IF_ABSENT,
} WriteStrategyRs_t;

/** <No documentation available> */
typedef struct DocIdResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    slice_boxed_uint8_t id;
} DocIdResult_t;

/** \brief
 *  Inserts a document into the store.
 *
 *  If an ID is provided explicitly via the `doc_id` parameter then that will be
 *  used as the document's ID. If an ID is provided implicitly via the
 *  document's value (`doc_cbor`) then that will be used as the document's ID,
 *  assuming no explicit ID was provided. If neither an explicit nor an implicit
 *  document ID was provided then a new document ID will be generated and used
 *  as the new document's ID.
 *
 *  Return codes:
 *
 *  * `0` -- success
 *  * `1` -- improper CBOR provided for the document value
 *  * `2` -- invalid CBOR for the document value (i.e. the CBOR could be parsed but it represented a
 *  non-`Object` value)
 *  * `3` -- unable to create document ID from value at `_id` key in document's value (`doc_cbor`
 *  argument)
 *  * `4` -- (js only) concurrent database operation (missing `await`?)
 */
DocIdResult_t
/* fn */ ditto_collection_insert_value (
    CDitto_t const * ditto,
    char const * coll_name,
    slice_ref_uint8_t doc_cbor,
    slice_ref_uint8_t doc_id,
    WriteStrategyRs_t write_strategy,
    char const * log_hint,
    CWriteTransaction_t * txn);

/** \brief
 *  Remove a document from the collection, using the provided write transaction.
 *
 *  `was_removed` is set to indicate whether the document was removed
 *  successfully.
 *
 *  * [js only] Returns -1 in case of outstanding non-`await`ed transaction operation.
 */
BoolResult_t
/* fn */ ditto_collection_remove (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    slice_ref_uint8_t id);

/** \brief
 *  Remove all documents returned by the specified query from a collection.
 *
 *  `out_ids` is set to the list of IDs of all documents successfully removed.
 *
 *  [js only] Returns -2 in case of outstanding non-awaited transaction operation.
 */
DocIdsResult_t
/* fn */ ditto_collection_remove_query_str (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by_params,
    int32_t limit,
    uint32_t offset);

/** \brief
 *  [js only] Returns -1 in case of outstanding non-awaited transaction operation.
 */
int32_t
/* fn */ ditto_collection_update (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    CDocument_t * document);

/** \brief
 *  Update multiple documents in a collection, using the provided write
 *  transaction.
 *
 *  # Return Values
 *
 *  - Returns `0` if all links were successfully updated in all documents.
 *  - Returns `-1` if one or more documents' links fail to all update
 *  successfully, but all documents themselves are successfully updated. Note
 *  that in the event of an attachment failing to update, updates are still
 *  attempted on the rest of the attachments and the rest of the documents.
 *  - If a document fails to update, the appropriate error code is returned for
 *  the cause of the failure. Note that if a document fails to update, no more
 *  document updates are attempted.
 */
int32_t
/* fn */ ditto_collection_update_multiple (
    CDitto_t const * ditto,
    char const * coll_name,
    CWriteTransaction_t * transaction,
    Vec_CDocument_ptr_t documents);

/** <No documentation available> */
int32_t
/* fn */ ditto_disable_sync_with_v2 (
    CDitto_t * ditto);

/** \brief
 *  List of components using the file storage system
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum FsComponent {
    /** <No documentation available> */
    FS_COMPONENT_ROOT = 0,
    /** <No documentation available> */
    FS_COMPONENT_STORE,
    /** <No documentation available> */
    FS_COMPONENT_AUTH,
    /** <No documentation available> */
    FS_COMPONENT_REPLICATION,
    /** <No documentation available> */
    FS_COMPONENT_ATTACHMENT,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
FsComponent_t;

/** \brief
 *  Get a cbor repr of the disk usage
 */
slice_boxed_uint8_t
/* fn */ ditto_disk_usage (
    CDitto_t * ditto,
    FsComponent_t path);

/** \brief
 *  Document's CBOR
 */
slice_boxed_uint8_t
/* fn */ ditto_document_cbor (
    CDocument_t const * document);

/** \brief
 *  Returns the document in CDS format (Canonical Document Structure) encoded as CBOR.
 */
slice_boxed_uint8_t
/* fn */ ditto_document_cds (
    CDocument_t const * document);

/** \brief
 *  Releases the document
 */
void
/* fn */ ditto_document_free (
    CDocument_t * document);

/** <No documentation available> */
slice_boxed_uint8_t
/* fn */ ditto_document_get_cbor (
    CDocument_t const * document,
    char const * pointer,
    DittoCrdtType_t variant);

/** \brief
 *  Gets the CBOR value at the path in the provided document and returns it if
 *  the value found matches the type requested, otherwise `None` will be
 *  returned in the result.
 *
 *  To understand how this is intended to be used it might be instructive to see
 *  how things work in the DittoDocumentPath of the Swift SDK, for example:
 *  <https://github.com/getditto/ditto/blob/v2/cocoa/DittoSwift/Store/DittoDocumentPath.swift#L63-L277>
 *
 *  where the valueAtPathInDocumentWithType implementation looks like this:
 *  <https://github.com/getditto/ditto/blob/259cfa64dd2c6b36ffee2e97514695ccbfff6755/cocoa/DittoSwift/Store/Internal/ValueAtPath.swift#L42-L49>
 *
 *  Note: all the of the values returned by
 *  `ditto_document_get_cbor_with_path_type` are untyped (i.e. theres never an
 *  object with `_value` and `_ditto_internal_type_jkb12973t4b` keys being
 *  returned). For example, if you request a value at a path with a
 *  `PathAccessorType` of `Counter` and there is indeed a counter at that path
 *  then the value (as CBOR) that will be returned will be the `f64`/`double`
 *  representation of the counters value, on its own.
 *
 *  If CBOR is returned in the result then the bytes have to be released with
 *  `::ditto_c_bytes_free`.
 */
CBORPathResult_t
/* fn */ ditto_document_get_cbor_with_path_type (
    CDocument_t const * document,
    char const * pointer,
    PathAccessorType_t path_type);

/** \brief
 *  Gets the CBOR value for the CRDT variant at the provided pointer.
 *
 *  The `.ptr` field will be `NULL` if no value was found (and the `.length`
 *  field will contain garbage)
 *
 *  The resulting bytes have to be released with `::ditto_c_bytes_free`
 */
slice_boxed_uint8_t
/* fn */ ditto_document_get_variant_cbor (
    CDocument_t const * document,
    char const * pointer,
    DittoCrdtType_t variant);

/** \brief
 *  Document's ID
 *
 *  The resulting bytes have to be freed with `::ditto_c_bytes_free`
 */
slice_boxed_uint8_t
/* fn */ ditto_document_id (
    CDocument_t const * document);

/** \brief
 *  Defines how string primitives should be encoded. This is relevant if a
 *  document ID was created from a string. There are occasions when we want the
 *  stringified representation of the document ID do include quotes around the
 *  string, for example when creating a query like `_id == "abc"`. However,
 *  there are also times when we want to return the string as just a string, for
 *  example when we're injecting a document ID into a document's value before
 *  then serializing the document and sending those bytes across the FFI
 *  boundary.
 */
typedef enum StringPrimitiveFormat {
    /** <No documentation available> */
    STRING_PRIMITIVE_FORMAT_WITH_QUOTES,
    /** <No documentation available> */
    STRING_PRIMITIVE_FORMAT_WITHOUT_QUOTES,
} StringPrimitiveFormat_t;

/** \brief
 *  Convert a document ID from CBOR bytes into a Ditto query language compatible
 *  string.
 *
 *  The resulting string has to be freed with `::ditto_c_string_free`
 */
char *
/* fn */ ditto_document_id_query_compatible (
    slice_ref_uint8_t id,
    StringPrimitiveFormat_t string_primitive_format);

/** <No documentation available> */
int32_t
/* fn */ ditto_document_increment_counter (
    CDocument_t * document,
    char const * pointer,
    double amount);

/** \brief
 *  Removes a value from a document. The behavior depends on the `Repr` of the
 *  element at the JMESPath path pointed to by `pointer`.
 *
 *  ```text
 *  // ________________________________________________________________________________________
 *  // |`pointer`   | Foo `Repr` | Action                                                     |
 *  // |------------|------------|------------------------------------------------------------|
 *  // | "foo.bar"  | Object     | Deletes bar property                                       |
 *  // | "foo[1]"   | Array      | Removes at index and shifts all subsequent indexes right   |
 *  // ----------------------------------------------------------------------------------------
 *  ```
 *
 *  # Arguments
 *
 *  * `document` - A pointer to the document which was previously returned from a query.
 *  * `pointer` - A JMESPath _pointer_ to a `Repr` within `document` which is to be removed.
 *
 *  # Returns
 *
 *  `0` if the remove was successful or non-zero to indicate failure. To
 *  retrieve an error message in the case of failure, call
 *  `ditto_error_message()`.
 */
int32_t
/* fn */ ditto_document_remove (
    CDocument_t * document,
    char const * pointer);

/** <No documentation available> */
int32_t
/* fn */ ditto_document_set_cbor (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor,
    bool create_path);

/** <No documentation available> */
int32_t
/* fn */ ditto_document_set_cbor_with_timestamp (
    CDocument_t * document,
    char const * pointer,
    slice_ref_uint8_t cbor,
    bool create_path,
    uint32_t timestamp);

/** \brief
 *  Updates the document with values taken from provided CBOR data.
 *
 *  Returns following error codes:
 *
 *  * `0` -- no error
 *  * `1` -- invalid CBOR data
 *  * `2` -- CBOR data was not a map
 *  * `3` -- update error
 *  * `4` -- `_id` key provided
 *  * `5` -- invalid value
 *
 *  In case of a non-zero return value, error message can be retrieved using
 *  `::ditto_error_message` function.
 */
int32_t
/* fn */ ditto_document_update (
    CDocument_t * document,
    slice_ref_uint8_t cbor,
    bool create_path);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_CDocument_ptr {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CDocument_t * const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_CDocument_ptr_t;

/** <No documentation available> */
typedef struct U64Result {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    uint64_t u64;
} U64Result_t;

/** <No documentation available> */
U64Result_t
/* fn */ ditto_documents_hash (
    slice_ref_CDocument_ptr_t documents);

/** <No documentation available> */
typedef struct BoxedCharPtrResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    char * c_string;
} BoxedCharPtrResult_t;

/** <No documentation available> */
BoxedCharPtrResult_t
/* fn */ ditto_documents_hash_mnemonic (
    slice_ref_CDocument_ptr_t documents);

/** \brief
 *  Calls ditto_shutdown and also:
 *  - Stops the live queries
 *  - Clears presence callback
 */
void
/* fn */ ditto_drop (
    CDitto_t * ditto);

/** \brief
 *  Retrieves last thread-local error message (used by some synchronous APIs)
 *  and removes it. Subsequent call to this function (if nothing else has
 *  happened) will always return `NULL`.
 *
 *  Returns `NULL` if there was no error. A non-null result MUST be freed using
 *  `ditto_c_string_free`.
 */
char *
/* fn */ ditto_error_message (void);

/** \brief
 *  Retrieves last thread-local error message (used by some synchronous APIs)
 *  and retains ownership of it.
 *
 *  Returns `NULL` if there was no error. A non-null result MUST be freed using
 *  `ditto_c_string_free`.
 */
char *
/* fn */ ditto_error_message_peek (void);

/** <No documentation available> */
void
/* fn */ ditto_executor_free (
    CExecutor_t * executor);

/** \brief
 *  Stop replication and all internal threads in the Ditto object. The ditto
 *  object is freed by this function and must not be used again.
 *  - Calls everything in ditto_drop
 *  - Calls everything in ditto_shutdown
 */
void
/* fn */ ditto_free (
    CDitto_t * ditto);

/** \brief
 *  A shared read-only reference to an existing Attachment.
 */
typedef struct AttachmentHandle AttachmentHandle_t;

/** <No documentation available> */
void
/* fn */ ditto_free_attachment_handle (
    AttachmentHandle_t * handle);

/** \brief
 *  Frees a `Vec_CDocument_ptr_t`, used in `c_cb_params`.
 *
 *  \remark This functions frees both the backing buffer allocation and each
 *  individual `Document` pointer. If ownership has been taken of the latter,
 *  then you must ensure the `len` field of the struct is zeroed before calling
 *  this function.
 */
void
/* fn */ ditto_free_documents (
    Vec_CDocument_ptr_t documents);

/** \brief
 *  [`Box`][`rust::Box`]`<[T]>` (fat pointer to a slice),
 *  but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_boxed_size {
    /** \brief
     *  Pointer to the first element (if any).
     */
    size_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_boxed_size_t;

/** \brief
 *  Frees a `slice_box_size_t`, used in `c_cb_params`.
 */
void
/* fn */ ditto_free_indices (
    slice_boxed_size_t indices);

/** <No documentation available> */
typedef struct AttachmentHandleResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    AttachmentHandle_t * handle;
} AttachmentHandleResult_t;

/** <No documentation available> */
AttachmentHandleResult_t
/* fn */ ditto_get_attachment_status (
    CDitto_t * ditto,
    slice_ref_uint8_t id);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_char_ptr {
    /** <No documentation available> */
    char * * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_char_ptr_t;

/** <No documentation available> */
typedef struct CollectionNamesResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    Vec_char_ptr_t names;
} CollectionNamesResult_t;

/** <No documentation available> */
CollectionNamesResult_t
/* fn */ ditto_get_collection_names (
    CDitto_t const * ditto);

/** <No documentation available> */
typedef struct AttachmentDataResult {
    /** <No documentation available> */
    int8_t status;

    /** <No documentation available> */
    slice_boxed_uint8_t data;
} AttachmentDataResult_t;

/** <No documentation available> */
AttachmentDataResult_t
/* fn */ ditto_get_complete_attachment_data (
    CDitto_t const * ditto,
    AttachmentHandle_t const * handle);

/** <No documentation available> */
char *
/* fn */ ditto_get_complete_attachment_path (
    CDitto_t const * ditto,
    AttachmentHandle_t const * handle);

/** \brief
 *  Returns a human-readable SDK version string.
 *
 *  The returned string must be freed.
 */
char *
/* fn */ ditto_get_sdk_version (void);

/** <No documentation available> */
typedef enum Platform {
    /** <No documentation available> */
    PLATFORM_WINDOWS,
    /** <No documentation available> */
    PLATFORM_MAC,
    /** <No documentation available> */
    PLATFORM_IOS,
    /** <No documentation available> */
    PLATFORM_ANDROID,
    /** <No documentation available> */
    PLATFORM_LINUX,
    /** <No documentation available> */
    PLATFORM_WEB,
    /** <No documentation available> */
    PLATFORM_UNKNOWN,
} Platform_t;

/** <No documentation available> */
typedef enum Language {
    /** <No documentation available> */
    LANGUAGE_SWIFT,
    /** <No documentation available> */
    LANGUAGE_OBJECTIVE_C,
    /** <No documentation available> */
    LANGUAGE_C_PLUS_PLUS,
    /** <No documentation available> */
    LANGUAGE_C_SHARP,
    /** <No documentation available> */
    LANGUAGE_JAVA_SCRIPT,
    /** <No documentation available> */
    LANGUAGE_UNKNOWN,
    /** <No documentation available> */
    LANGUAGE_RUST,
} Language_t;

/** <No documentation available> */
void
/* fn */ ditto_init_sdk_version (
    Platform_t platform,
    Language_t language,
    char const * sdk_semver);

typedef struct {
    uint8_t idx[8];
} uint8_8_array_t;

/** \brief
 *  Construct a new Timeseries Event from the following parts:
 *  * `timestamp` - u64 Unix epoch seconds as 8 big endian bytes
 *  * `nanos` - Number of nanoseconds offset into the current second
 *  * `ts_name` - The name of the timeseries
 *  * `cbor` - The cbor content for the event
 *  * `txn` - An optional write transaction. If one is provided then it will not be committed. If
 *  one is not provided then one will be obtained and it will be committed.
 *
 *  Return codes:
 *  * `0` -- success
 *  * `1` -- invalid CBOR
 *  * `2` -- `cbor` is not an object
 *  * `3` -- (js only) concurrent database operation (missing `await`?)
 */
int32_t
/* fn */ ditto_insert_timeseries_event (
    CDitto_t const * ditto,
    uint8_8_array_t timestamp,
    uint32_t nanos,
    char const * ts_name,
    slice_ref_uint8_t cbor,
    CWriteTransaction_t * txn);

/** <No documentation available> */
void
/* fn */ ditto_invalidate_tcp_listeners (
    CDitto_t const * ditto);

/** \brief
 *  Describes how a live query callback's availability should be treated.
 *
 *  If `Always` is specified then as soon as a transaction is committed that
 *  impacts the live query the consumer-provided callback will be called with
 *  the relevant update information. This can be temporarily delayed if there's
 *  a lot of activity leading to the event receivers lagging or if groups of
 *  transactions are coalesced into a single live query update.
 *
 *  If `WhenSignalled` is specified then the consumer-provided live query
 *  callback will only be called when there is a transaction committed that
 *  impacts the live query *and* the consumer has signalled that they are ready
 *  to receive a new live query event (via the callback).
 */
typedef enum LiveQueryAvailability {
    /** <No documentation available> */
    LIVE_QUERY_AVAILABILITY_ALWAYS,
    /** <No documentation available> */
    LIVE_QUERY_AVAILABILITY_WHEN_SIGNALLED,
} LiveQueryAvailability_t;

/** <No documentation available> */
typedef struct c_cb_params {
    /** \brief
     *  Must be freed with `ditto_free_documents`.
     */
    Vec_CDocument_ptr_t documents;

    /** <No documentation available> */
    bool is_initial;

    /** \brief
     *  Must be freed with `ditto_free_documents`.
     */
    Vec_CDocument_ptr_t old_documents;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t insertions;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t deletions;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t updates;

    /** \brief
     *  Must be freed using `ditto_free_indices`.
     */
    slice_boxed_size_t moves;
} c_cb_params_t;

/** <No documentation available> */
typedef struct I64Result {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    int64_t i64;
} I64Result_t;

/** \brief
 *  Convenience function for `ditto_live_query_register`, so as not to require
 *  pre-compiling the query.
 */
I64Result_t
/* fn */ ditto_live_query_register_str (
    CDitto_t const * ditto,
    char const * coll_name,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by,
    int32_t limit,
    uint32_t offset,
    LiveQueryAvailability_t lq_availability,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, c_cb_params_t));

/** <No documentation available> */
void
/* fn */ ditto_live_query_signal_available_next (
    CDitto_t const * ditto,
    int64_t id);

/** <No documentation available> */
int32_t
/* fn */ ditto_live_query_start (
    CDitto_t const * ditto,
    int64_t id);

/** <No documentation available> */
void
/* fn */ ditto_live_query_stop (
    CDitto_t const * ditto,
    int64_t id);

/** <No documentation available> */
int32_t
/* fn */ ditto_live_query_webhook_generate_new_api_secret (
    CDitto_t const * ditto);

/** <No documentation available> */
DocIdResult_t
/* fn */ ditto_live_query_webhook_register_str (
    CDitto_t const * ditto,
    char const * coll_name,
    char const * query,
    slice_ref_COrderByParam_t order_by,
    int32_t limit,
    uint32_t offset,
    char const * url);

/** <No documentation available> */
int32_t
/* fn */ ditto_live_query_webhook_start_all (
    CDitto_t const * ditto);

/** <No documentation available> */
int32_t
/* fn */ ditto_live_query_webhook_start_by_id (
    CDitto_t const * ditto,
    slice_ref_uint8_t id);

/** <No documentation available> */
typedef enum CLogLevel {
    /** <No documentation available> */
    C_LOG_LEVEL_ERROR = 1,
    /** <No documentation available> */
    C_LOG_LEVEL_WARNING,
    /** <No documentation available> */
    C_LOG_LEVEL_INFO,
    /** <No documentation available> */
    C_LOG_LEVEL_DEBUG,
    /** <No documentation available> */
    C_LOG_LEVEL_VERBOSE,
} CLogLevel_t;

/** \brief
 *  Log function called over FFI such that logging can be grouped into a single
 *  logging mechanism.
 */
void
/* fn */ ditto_log (
    CLogLevel_t level,
    char const * msg);

/** <No documentation available> */
void
/* fn */ ditto_logger_emoji_headings_enabled (
    bool enabled);

/** <No documentation available> */
bool
/* fn */ ditto_logger_emoji_headings_enabled_get (void);

/** <No documentation available> */
void
/* fn */ ditto_logger_enabled (
    bool enabled);

/** <No documentation available> */
bool
/* fn */ ditto_logger_enabled_get (void);

/** \brief
 *  Initializes and registers the global Ditto logger.
 */
void
/* fn */ ditto_logger_init (void);

/** <No documentation available> */
void
/* fn */ ditto_logger_minimum_log_level (
    CLogLevel_t log_level);

/** <No documentation available> */
CLogLevel_t
/* fn */ ditto_logger_minimum_log_level_get (void);

/** \brief
 *  Registers a custom logging callback to be called whenever Ditto wants to
 *  issue a log (on _top_ of emitting the log to the console).
 *
 *  Care should be taken not to perform any Ditto operations within this
 *  callback, since those could emit new ditto logs, leading to a recursive
 *  situation. More specifically, this should not be fed `ditto_log`.
 *
 *  A `NULL` may be fed to provide no callback (thus unregistering any
 *  previously registered one).
 */
void
/* fn */ ditto_logger_set_custom_log_cb (
    void (*custom_log_cb)(CLogLevel_t, char const *));

/** \brief
 *  Registers a file path where logs will be written to, whenever Ditto wants
 *  to issue a log (on _top_ of emitting the log to the console).
 *
 *  The path, if any, must be within an already existing directory.
 *
 *  A `NULL` may be fed to provide no file (thus unregistering any previously
 *  registered one).
 *
 *  Returns `0` on success, and `-1` otherwise (and the thread local error
 *  message is set accordingly).
 */
int8_t
/* fn */ ditto_logger_set_log_file (
    char const * log_file);

/** <No documentation available> */
typedef struct UninitializedDitto UninitializedDitto_t;

/** \brief
 *  Whether or not history tracking is enabled.
 */
typedef enum HistoryTracking {
    /** <No documentation available> */
    HISTORY_TRACKING_ENABLED,
    /** <No documentation available> */
    HISTORY_TRACKING_DISABLED,
} HistoryTracking_t;

/** \brief
 *  Make a Ditto object as an opaque pointer. The Ditto object creates the Tokio
 *  runtime and starts internal threads. The return value is a raw pointer whose
 *  only use is to supply as an argument to other ditto_* functions. The Ditto
 *  object must be stopped and freed with ditto_free().
 */
CDitto_t *
/* fn */ ditto_make (
    UninitializedDitto_t * uninit_ditto,
    CAuthClient_t const * auth_client,
    HistoryTracking_t history_tracking);

/** <No documentation available> */
CExecutor_t *
/* fn */ ditto_make_executor_from_handle (
    void * handle);

/** <No documentation available> */
CExecutor_t *
/* fn */ ditto_make_executor_from_runtime (
    void const * runtime);

/** <No documentation available> */
CExecutor_t *
/* fn */ ditto_make_executor_new_runtime (void);

/** <No documentation available> */
typedef struct CAttachment {
    /** <No documentation available> */
    slice_boxed_uint8_t id;

    /** <No documentation available> */
    uint64_t len;

    /** <No documentation available> */
    AttachmentHandle_t * handle;
} CAttachment_t;

/** \brief
 *  Creates new Attachment from a blob of bytes link it to the given Document.
 *
 *  Returns following error codes:
 *
 *  * `0` -- no error
 *  * `1` -- an error
 *
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
uint32_t
/* fn */ ditto_new_attachment_from_bytes (
    CDitto_t const * ditto,
    slice_ref_uint8_t bytes,
    CAttachment_t * out_attachment);

/** \brief
 *  Describes how an attachment file should be handled by our Rust code.
 *
 *  In most cases copying the file will be desirable but with the Android SDK,
 *  for example, we sometimes want to create a tempfile from an InputStream
 *  associated with the attachment file and then move that tempfile rather than
 *  copy it, so as to not make unnecessary copies.
 */
typedef enum AttachmentFileOperation {
    /** <No documentation available> */
    ATTACHMENT_FILE_OPERATION_COPY = 1,
    /** <No documentation available> */
    ATTACHMENT_FILE_OPERATION_MOVE,
} AttachmentFileOperation_t;

/** \brief
 *  Creates new Attachment from a file and link it to the given Document.
 *
 *  Returns following error codes:
 *
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- file not found
 *  * `3` -- permission denied
 *
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
uint32_t
/* fn */ ditto_new_attachment_from_file (
    CDitto_t const * ditto,
    char const * source_path,
    AttachmentFileOperation_t file_operation,
    CAttachment_t * out_attachment);

/** \brief
 *  Allow to free the Vector without dropping the Documents
 */
void
/* fn */ ditto_only_vec_documents_free (
    Vec_CDocument_ptr_t docs);

/** \brief
 *  Request data showing who we are connected to in a user-friendly way.
 */
char *
/* fn */ ditto_presence_v1 (
    CDitto_t * ditto);

/** \brief
 *  Request data showing who we are connected to in a user-friendly way.
 */
char *
/* fn */ ditto_presence_v2 (
    CDitto_t * ditto);

/** \brief
 *  Request data showing who we are connected to in a user-friendly way.
 */
char *
/* fn */ ditto_presence_v3 (
    CDitto_t * ditto);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_char_const_ptr {
    /** \brief
     *  Pointer to the first element (if any).
     */
    char const * const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_char_const_ptr_t;

/** <No documentation available> */
U64Result_t
/* fn */ ditto_queries_hash (
    CDitto_t const * ditto,
    slice_ref_char_const_ptr_t coll_names,
    slice_ref_char_const_ptr_t queries);

/** <No documentation available> */
BoxedCharPtrResult_t
/* fn */ ditto_queries_hash_mnemonic (
    CDitto_t const * ditto,
    slice_ref_char_const_ptr_t coll_names,
    slice_ref_char_const_ptr_t queries);

/** <No documentation available> */
typedef struct CReadTransactionResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    CReadTransaction_t * txn;
} CReadTransactionResult_t;

/** <No documentation available> */
CReadTransactionResult_t
/* fn */ ditto_read_transaction (
    CDitto_t const * ditto);

/** <No documentation available> */
void
/* fn */ ditto_read_transaction_free (
    CReadTransaction_t * transaction);

/** \brief
 *  Holder of the disk usage callback
 *  Drop this to stop the callback
 */
typedef struct DiskUsageObserver DiskUsageObserver_t;

/** \brief
 *  Register a function that will be called every time
 *  the given path directory or file is updated.
 *  Return a handle that should be given to ditto_release_disk_usage_callback
 *  to drop the callback
 */
DiskUsageObserver_t *
/* fn */ ditto_register_disk_usage_callback (
    CDitto_t * ditto,
    FsComponent_t component,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, slice_boxed_uint8_t));

/** \brief
 *  Register a server that can authenticate client requests for an identity.
 *
 *  Its route will be included in the HTTP server transport, if configured.
 */
int32_t
/* fn */ ditto_register_local_auth_server (
    CDitto_t * ditto,
    char const * signing_key_pem,
    slice_ref_char_const_ptr_t verifying_keys_pem,
    char const * ca_key_pem,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*auth_cb)(void *, CAuthServerAuthRequest_t *, slice_ref_uint8_t),
    void (*refresh_cb)(void *, CAuthServerRefreshRequest_t *, slice_ref_uint8_t));

/** \brief
 *  Register a function that will be called every time the connection state
 *  of remote peers changes.
 */
void
/* fn */ ditto_register_presence_callback_v3 (
    CDitto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, char const *));

/** \brief
 *  Register a function that will be called every time the connection state
 *  of remote peers changes.
 *  REMOVE THIS IN V4
 */
void
/* fn */ ditto_register_presence_v1_callback (
    CDitto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, char const *));

/** \brief
 *  Register a function that will be called every time the connection state
 *  of remote peers changes.
 *  REMOVE THIS IN V4
 */
void
/* fn */ ditto_register_presence_v2_callback (
    CDitto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, char const *));

/** \brief
 *  User-friendly categories describing where condition events arose
 */
typedef enum ConditionSource {
    /** <No documentation available> */
    CONDITION_SOURCE_BLUETOOTH,
    /** <No documentation available> */
    CONDITION_SOURCE_TCP,
    /** <No documentation available> */
    CONDITION_SOURCE_AWDL,
    /** <No documentation available> */
    CONDITION_SOURCE_MDNS,
    /** <No documentation available> */
    CONDITION_SOURCE_WIFI_AWARE,
} ConditionSource_t;

/** \brief
 *  Register a function that will be called every time a transport changes
 *  condition.
 *
 *  This should drive UI indicators to indicate overall connectivity via methods
 *  such as BLE, WiFi, or an internet-based server on a dedicated
 *  WsConnectTransport.
 */
void
/* fn */ ditto_register_transport_condition_changed_callback (
    CDitto_t * ditto,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*c_cb)(void *, ConditionSource_t, TransportCondition_t));

/** \brief
 *  Release the disk usage observer obtained from `ditto_register_disk_usage_callback`
 */
void
/* fn */ ditto_release_disk_usage_callback (
    DiskUsageObserver_t * _handle);

/** <No documentation available> */
void
/* fn */ ditto_remove_mdns_advertiser (
    CDitto_t const * ditto);

/** <No documentation available> */
void
/* fn */ ditto_remove_multicast_transport (
    CDitto_t * ditto);

/** <No documentation available> */
int32_t
/* fn */ ditto_remove_subscription (
    CDitto_t const * ditto,
    char const * collection,
    char const * query,
    slice_ref_uint8_t query_args_cbor,
    slice_ref_COrderByParam_t order_by,
    int32_t limit,
    uint32_t offset);

/** <No documentation available> */
typedef struct CancelTokenResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    int64_t cancel_token;
} CancelTokenResult_t;

/** \brief
 *  Register a new callback to resolve the attachment.
 *
 *  The callback status could be:
 *  * `0` -- complete, with a handle that can be used in ditto_get_complete_attachment_path
 *  * `1` -- progress, with additional info about bytes downloaded and total bytes to download
 *  * `2` -- deleted, as the attachment ceased to exist in the doc database
 *
 *  Returns following error codes:
 *
 *  * `0` -- no error
 *  * `1` -- an error
 *  * `2` -- invalid id
 *  * `3` -- attachment not found
 *
 *  In case of a non-zero return value, error message can be retrieved using
 *  `ditto_error_message` function.
 */
CancelTokenResult_t
/* fn */ ditto_resolve_attachment (
    CDitto_t const * ditto,
    slice_ref_uint8_t id,
    void * ctx,
    void (*retain)(void *),
    void (*release)(void *),
    void (*on_complete_cb)(void *, AttachmentHandle_t *),
    void (*on_progress_cb)(void *, uint64_t, uint64_t),
    void (*on_deleted_cb)(void *));

/** <No documentation available> */
uint32_t
/* fn */ ditto_run_garbage_collection (
    CDitto_t * ditto);

/** <No documentation available> */
void
/* fn */ ditto_set_device_name (
    CDitto_t * ditto,
    char const * device_name);

/** <No documentation available> */
void
/* fn */ ditto_set_max_outgoing_ble_peers (
    uint32_t count);

/** <No documentation available> */
uint32_t
/* fn */ ditto_set_priority_for_query_overlap_group (
    CDitto_t * ditto,
    uint8_t prio,
    uint8_t query_overlap_group);

/** <No documentation available> */
uint32_t
/* fn */ ditto_set_query_overlap_group (
    CDitto_t * ditto,
    uint8_t query_overlap_group);

/** <No documentation available> */
void
/* fn */ ditto_set_sync_group (
    CDitto_t * ditto,
    uint32_t sync_group);

/** \brief
 *  Shutdown as much of the Ditto Peer as possible via interior mutability
 *  - shuts down all advertisers
 *  - stops all servers
 *  - stops all TCP listeners
 *  - Outbound replication should stop when the peer is dropped
 */
void
/* fn */ ditto_shutdown (
    CDitto_t const * ditto);

/** \brief
 *  Whether or not to offer a WebSocket sync server on the HTTP server.
 */
typedef enum WebSocketMode {
    /** <No documentation available> */
    WEB_SOCKET_MODE_ENABLED,
    /** <No documentation available> */
    WEB_SOCKET_MODE_DISABLED,
} WebSocketMode_t;

/** \brief
 *  Start the WebSocket server
 *
 *  * `bind` - optional bind string of the form "ip:port"
 *  * `static_path` - optional absolute path to content on disk that should be served from `/`
 *  * `enable_websocket` - whether to enable a WebSocket server at the reserved path `/_ditto/ws`
 *  * `tls_cert_path` - path to this server's TLS certificate file, or null if not using TLS
 *  * `tls_key_path` - path to this server's TLS private key file, or null if not using TLS
 */
int32_t
/* fn */ ditto_start_http_server (
    CDitto_t const * ditto,
    char const * bind,
    char const * static_path,
    WebSocketMode_t enable_websocket,
    char const * tls_cert_path,
    char const * tls_key_path);

/** \brief
 *  Start the WebSocket server
 */
int32_t
/* fn */ ditto_start_tcp_server (
    CDitto_t const * ditto,
    char const * bind);

/** <No documentation available> */
void
/* fn */ ditto_stop_all_live_queries (
    CDitto_t const * ditto);

/** <No documentation available> */
int32_t
/* fn */ ditto_stop_http_server (
    CDitto_t const * ditto);

/** <No documentation available> */
int32_t
/* fn */ ditto_stop_tcp_server (
    CDitto_t const * ditto);

/** \brief
 *  Listen address of `tcp_listen_transport`.
 *
 *  Must be called after `transport_go_online()`.
 *  The return value must be freed with `ditto_c_string_free()`.
 */
char *
/* fn */ ditto_tcp_server_listen_addr (
    CDitto_t * ditto);

/** \brief
 *  Request bulk status information about the transports. Intended mostly for
 *  statistical or debugging purposes.
 */
char *
/* fn */ ditto_transports_diagnostics (
    CDitto_t * ditto);

/** <No documentation available> */
void
/* fn */ ditto_unregister_local_auth_server (
    CDitto_t * ditto);

/** <No documentation available> */
uint32_t
/* fn */ ditto_validate_document_id (
    slice_ref_uint8_t cbor,
    slice_boxed_uint8_t * out_cbor);

/** <No documentation available> */
void
/* fn */ ditto_vec_char_ptr_free (
    Vec_char_ptr_t char_p);

/** <No documentation available> */
void
/* fn */ ditto_vec_slice_boxed_uint8_t_free (
    Vec_slice_boxed_uint8_t slice_boxed);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_size {
    /** <No documentation available> */
    size_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_size_t;

/** <No documentation available> */
void
/* fn */ ditto_vec_usizes_free (
    Vec_size_t usizes);

/** \brief
 *  The SDK requests to drop its handle to the WifiAware discovery transport
 *
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void
/* fn */ ditto_wifi_aware_client_free_handle (
    TransportHandle_WifiAwareClientPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that we have resolved a peer's hostname and port
 */
void
/* fn */ ditto_wifi_aware_client_network_did_create (
    TransportHandle_WifiAwareClientPlatformEvent_t const * handle,
    char const * announce_string,
    char const * hostname,
    uint16_t port);

/** \brief
 *  The platform advises Rust that a peer has been identified.
 */
void
/* fn */ ditto_wifi_aware_client_peer_appeared (
    TransportHandle_WifiAwareClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that we failed to resolve a peer's hostname and
 *  port
 */
void
/* fn */ ditto_wifi_aware_client_peer_did_not_connect (
    TransportHandle_WifiAwareClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that a peer's service has disappeared from WifiAware.
 */
void
/* fn */ ditto_wifi_aware_client_peer_disappeared (
    TransportHandle_WifiAwareClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that the status of searching for services has
 *  changed.
 */
void
/* fn */ ditto_wifi_aware_client_scanning_state_changed (
    TransportHandle_WifiAwareClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The platform advises Rust that the status of publishing our service has
 *  changed.
 */
void
/* fn */ ditto_wifi_aware_server_advertising_state_changed (
    TransportHandle_WifiAwareServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The SDK requests to drop its handle to the WifiAware advertising service.
 *
 *  Ideally this should remove the advertiser automatically.
 *  At time of writing now this must be done manually through Peer.
 */
void
/* fn */ ditto_wifi_aware_server_free_handle (
    TransportHandle_WifiAwareServerPlatformEvent_t * handle);

/** <No documentation available> */
typedef struct CWriteTransactionResult {
    /** <No documentation available> */
    int32_t status_code;

    /** <No documentation available> */
    CWriteTransaction_t * txn;
} CWriteTransactionResult_t;

/** <No documentation available> */
CWriteTransactionResult_t
/* fn */ ditto_write_transaction (
    CDitto_t const * ditto,
    char const * log_hint);

/** \brief
 *  Sets some arbitrary metadata on a write transaction.
 *
 *  This is currently only useful and relevant if history tracking is enabled in
 *  the store that the write transaction relates to. If history tracking is
 *  enabled and metadata is set on a write transaction then the document
 *  inserted into the `__history` collection will have (at least) the provided
 *  metadata stored under the `meta` key of the document.
 *
 *  Return codes:
 *
 *  * `0` -- success
 *  * `1` -- invalid metadata CBOR
 *  * `-1` -- valid metadata CBOR but the CBOR does not represent an object
 *  * `-2` -- missing `await`s
 */
int32_t
/* fn */ ditto_write_transaction_add_metadata (
    CWriteTransaction_t * transaction,
    slice_ref_uint8_t metadata_cbor);

/** <No documentation available> */
int32_t
/* fn */ ditto_write_transaction_commit (
    CDitto_t const * ditto,
    CWriteTransaction_t * transaction);

/** <No documentation available> */
void
/* fn */ ditto_write_transaction_free (
    CWriteTransaction_t * transaction);

/** \brief
 *  Returns -1 on failure, in case of missing `await`s.
 */
int32_t
/* fn */ ditto_write_transaction_rollback (
    CDitto_t const * _ditto,
    CWriteTransaction_t * transaction);

/** <No documentation available> */
void
/* fn */ free_c_string_vec (
    Vec_char_ptr_t * strings);

/** \brief
 *  The platform advises Rust that the status of publishing our service has
 *  changed.
 */
void
/* fn */ mdns_advertising_state_changed (
    TransportHandle_MdnsServerPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The SDK requests to drop its handle to the mDNS discovery transport
 *
 *  At some point dropping this events channel will effectively shut down and
 *  remove the Transport. At time of writing, the Transport is still owned
 *  within Peer.
 */
void
/* fn */ mdns_client_free_handle (
    TransportHandle_MdnsClientPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that a peer has been identified.
 */
void
/* fn */ mdns_platform_peer_appeared (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that a peer's service has disappeared from mDNS.
 */
void
/* fn */ mdns_platform_peer_disappeared (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that the status of searching for services has
 *  changed.
 */
void
/* fn */ mdns_scanning_state_changed (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    OnlineState_t state,
    TransportCondition_t condition);

/** \brief
 *  The SDK requests to drop its handle to the mDNS advertising service.
 *
 *  Ideally this should remove the advertiser automatically.
 *  At time of writing now this must be done manually through Peer.
 */
void
/* fn */ mdns_server_free_handle (
    TransportHandle_MdnsServerPlatformEvent_t * handle);

/** \brief
 *  The platform advises Rust that we failed to resolve a peer's hostname and
 *  port
 */
void
/* fn */ mdns_service_did_not_resolve (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string);

/** \brief
 *  The platform advises Rust that we have resolved a peer's hostname and port
 */
void
/* fn */ mdns_service_did_resolve (
    TransportHandle_MdnsClientPlatformEvent_t const * handle,
    char const * announce_string,
    char const * hostname,
    uint16_t port);

/** <No documentation available> */
Vec_char_ptr_t *
/* fn */ new_c_string_vec (void);

/** \brief
 *  The SDK requests to drop its handle to this TCP Client transport
 */
void
/* fn */ static_tcp_client_free_handle (
    TransportHandle_StaticTcpClientPlatformEvent_t * handle);

/** \brief
 *  Make an UninitializedDitto object as an opaque pointer.
 *
 *  This object serves as an intermediate object that allows database access.
 *  This allows the SDK to check if a pre-existing site ID has been persisted.
 */
UninitializedDitto_t *
/* fn */ uninitialized_ditto_make (
    char const * working_dir);

/** <No documentation available> */
UninitializedDitto_t *
/* fn */ uninitialized_ditto_make_with_executor (
    char const * working_dir,
    CExecutor_t * executor);

/** <No documentation available> */
typedef enum LicenseVerificationResult {
    /** <No documentation available> */
    LICENSE_VERIFICATION_RESULT_LICENSE_OK = 0,
    /** <No documentation available> */
    LICENSE_VERIFICATION_RESULT_VERIFICATION_FAILED = -1,
    /** <No documentation available> */
    LICENSE_VERIFICATION_RESULT_LICENSE_EXPIRED = -2,
    /** <No documentation available> */
    LICENSE_VERIFICATION_RESULT_UNSUPPORTED_FUTURE_VERSION = -3,
} LicenseVerificationResult_t;

/** \brief
 *  Verify a base64 encoded license string
 *
 *  # Parameters
 *  - `license`: A base64 encoded license string. This should be the output of
 *  `ditto_licenser::license_mgr::generate()`.
 *  - `out_error_msg`: An optional error message out parameter which will be written to if the
 *  license verification. This error message is simplified and appropriate to show directly to an
 *  SDK user.
 */
LicenseVerificationResult_t
/* fn */ verify_license (
    char const * license,
    char * * out_err_msg);

/** \brief
 *  The SDK requests to drop its handle to this WebSocket Client transport
 */
void
/* fn */ websocket_client_free_handle (
    TransportHandle_WebsocketClientPlatformEvent_t * handle);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_DITTOFFI__ */
